1) O init (npm init -y) do node não tem instalação dop TypeScript, por isso instalamos manualmente como dependência de Desenvolvimento:

```npm i -D typescript```

E o tsconfig dele:

```npx tsc --init```

E modificarmos dentro desse tsconfig.json o target na linha 14. É a versão de JS pra qual vamos converter nosso código:

es2016 -> ES2020

Para converter o código do arquivo ts para js e depois rodá-lo com node:

```npx tsc src/index.ts```
```node src/index.js```

Claro, não fazemos isso o tempo todo. Temos FERRAMENTAS DE CONVERSÃO.

2) Framework Base do projeto: Fastify

```npm i fastify```

Como o node não foi construído com TS, precisamos também instalar o pacote do @types/node:

```npm install -D @types/node```

para que funcione o ```npx tsc src/server.ts```

E executemos o server: ```node src/server.js```

É claro que isso é automatizado através do tsx:

```npm install tsx -D``` e o comando:

```npx tsx src/server.ts``` sem necessidade de criar o arquivo js. Porém, só em desenvolvimento fazemos tudo isso. Por isso o -D. Em produção, ocorre a conversão em .js e tudo feito anteriormente, porque rodar o js é muito mais rápido/performático.

De qualquer forma, colocamos no script com tsx watch para monitorar mudanças também.


3) ESTRATÉGIA DE ACESSO AO BANCO DE DADOS DESTE MÓDULO:

QUERY BUILDERS - Basicamente, fazem comandos de SQL utilizando a linguagem de JavaScript. Exemplo https://knexjs.org/guide/query-builder.html#where

Configuração - npm install knex sqlite3

sqlite3 é uma das opções para DB, no caso a que usaremos com o Knex

"sqlite_schema" é uma tabela criada automaticamente no knex, mesmo que na ausência de tabela retorne só um array vazio;

A pasta tmp é de temporary, onde fica o banco de dados criado localmente. Ela vai para o .gitignore pois não faz parte da prática subir o banco no projeto.

4) Migration - "npx knex -h" (de help) mostra todos os comandos que podemos executar do knex. Dentre eles, os migrate. Usaremos o migrate e criaremos uma nova tabela chamada documents:

"npx knex migrate:make create-transactions", mas criando antes um knexfile para ele saber da existência do database. Nele, apensar importamos e exportamos a config que utilizamos no database.

Outro passo necessário para evitar os erros é ajustar a parte de typescript, pois o knex não suporta o tsx que estamos usando no projeto. Por isso, criamos um novo script chamado knex, com um comando de leitura do tsx via node; ele é direcionado ao knexfile para fazer a leitura para nós. Daí executamos o script separando o -h para ser entendido como do knex em vez do npm:

"npm run knex -- -h" e depois, finalmente, o migrate:

"npm run knex -- migrate:make create-documents"
Também adicionamos configurações em database através da interface Knex: Knex.Config

5) Criando tabela com a migration, craindo métodos up e down dentro dela e executando:

"npm run knex -- migrate:latest"

Ao usar o run dev e verificar a porta com /hello, observamos todas as tabelas criadas pela migration. REGRA: Uma vez que uma migration foi enviada para o restante do time, ela NUNCA MAIS PODERÁ SER EDITADA. Será preciso criar uma nova. PORÉM, se ainda não foi enviada, podemos usar o comando para desfazer a migration:

"npm run knex -- migrate:rollback"

Adicionadas mudanças, criamos de novo a tabela. Depois, há um comando que faz uma migration adicionar algo novo, no caso um session id para a tabela transaction:

"npm run knex -- migrate:make add-session-id-to-transactions"

E editamos seus up e down e rodamos o :latest novamente: "npm run knex -- migrate:latest"


6) Exemplos de queries feitos lá no server.ts:

app.get('/hello', async () => {
  // const tables = await knex('sqlite_schema').select('*');
  // return tables; Experimentando outras operações:

  // // Inserção:
  // const transactions = await knex('transactions')
  //   .insert({
  //     id: crypto.randomUUID(),
  //     title: 'Transação de teste',
  //     amount: 1000,
  //   })
  //   .returning('*'); // Returning faz a rota retornar os dados da transação, e não só um [1]

  // Busca/select:
  const transactions = await knex('transactions')
    .where('amount', 1000)
    .select('*'); // Só o select * seleciona todos na busca
  return transactions;
});

7) Trabalhar com variáveis de ambiente:

Instalar extensão DotENV, para ler esses arquivos.
Instalar a dependência: npm i dotenv

Depois importamos no database.ts o dotenv/config, que lerá automaticamente o arquivo .env que criamos e vai expor todos os valores que temos nele através da variável global process.env (dar console pra testar)

8) Pontuando Requisitos da Aplicação (Normalmente realizado com um README.md):

Requisitos Funcionais (RF):

- [ ] O usuário deve poder criar uma nova transação;
- [ ] O usuário deve poder obter um resumo da sua conta;
- [ ] O usuário deve poder listas todas as transações que já ocorreram;
- [ ] O usuário deve poder visualizar uma transação única;

Regras de Negócio (RN):

- [ ] A transação pode ser do tipo crédito que somará ao valor total, ou débito que subtrairá;
- [ ] Deve ser possível identificarmos o usuário entre as requisições;
- [ ] O usuário só pode visualizar transações o qual ele criou;

Requisitos Não-Funcionais (RNF):
- [ ]
